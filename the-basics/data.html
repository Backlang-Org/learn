<h1 id="working-with-data">Working With Data</h1>
<h2 id="structs">Structs</h2>
<h2 id="declaring-structs">Declaring structs</h2>
<p>A struct is something like a wrapper for different values. It is a valuetype and allocated on the stack (.Net, it can differe for other backends). A struct can only have values. </p>
<p>The syntactic structure of a struct:</p>
<pre><code class="language-ebnf">&lt;<span class="token rule">struct_value</span>> ::<span class="token operator">=</span> <span class="token string">"let"</span> &lt;<span class="token rule">name</span>> <span class="token string">":"</span> &lt;<span class="token rule">typename</span>> <span class="token string">";"</span>
&lt;<span class="token rule">struct_declaration</span>> ::<span class="token operator">=</span> &lt;<span class="token rule">modifier</span>>? <span class="token string">"struct"</span> &lt;<span class="token rule">name</span>> <span class="token string">"{"</span> &lt;<span class="token rule">struct_value</span>><span class="token operator">*</span> <span class="token string">"}"</span>
</code></pre>
<p>For the struct an automatic constructor will be generated to init all fields.</p>
<p>A simple example:</p>
<pre><code class="language-back"><span class="token keyword">public</span> <span class="token keyword">struct</span> Point {
    <span class="token keyword">let</span> X : <span class="token keyword">i32</span>;
    <span class="token keyword">let</span> Y : <span class="token keyword">i32</span>;
}
</code></pre>
<h2 id="working-with-structs">Working with structs</h2>
<p>To create an instance of a struct you have to call the constructor. </p>
<pre><code class="language-back"><span class="token keyword">let</span> p = Point::new(<span class="token number">5</span>, <span class="token number">8</span>);
</code></pre>
<p>The code above creates a new instance of the struct <code>Point</code> and calls the constructor to initialize the field <code>X</code> with 5 and the field <code>Y</code> with 8.</p>
<p>To pass a specific field to a function for example you can use the <code>.</code>-operator.</p>
<pre><code class="language-back">print(p.X);
print(p.Y);
</code></pre>
<h2 id="tuples">Tuples</h2>
<p>A tuple is like an anonymous struct. It can hold values but it doesn&#39;t have a name. Tuples can be used to map or return multiple values. A tuple can hold up to 8 values. </p>
<p>Here is a simple example:</p>
<pre><code class="language-back"><span class="token keyword">let</span> myTuple : (<span class="token keyword">i32</span>, <span class="token keyword">bool</span>) = (<span class="token number">42</span>, <span class="token boolean">true</span>);
</code></pre>
<pre><code class="language-back"><span class="token keyword">func</span> doSomething() -> (<span class="token keyword">i32</span>, <span class="token keyword">string</span>) {
    <span class="token keyword">return</span> (<span class="token number">1</span>, <span class="token string">"Some Error Occured"</span>);
}
</code></pre>
<h2 id="ranges">Ranges</h2>
<p>A range represents a range of numbers or in some contexts a range of types. A range has a lover and a upper bound.</p>
<pre><code class="language-back"><span class="token keyword">let</span> range = <span class="token number">1</span>..<span class="token number">200</span>;
</code></pre>
<p>The sample above uses a range from 1 to 200 inclusive. That means an array will be instanciatet with all the values from 1 to 200.</p>
<h2 id="exercices">Exercices</h2>
<ol>
<li>Expplain the difference between a struct and a tuple.</li>
<li>Is it possible to nest tuples?</li>
<li>How much values can hold a tuple?</li>
</ol>
<h2 id="unit-types">Unit Types</h2>
<p>A unit type can gives a literal a typed unit. So if you want to ensure that you are working with the right number unit you can use it. </p>
<p>To define a simple unit type:</p>
<pre><code class="language-ebnf">&lt;<span class="token rule">unit_def</span>> ::<span class="token operator">=</span> <span class="token string">"unit"</span> &lt;<span class="token rule">name</span>> <span class="token string">";"</span>
</code></pre>
<p>A simple example for a definition and usage of an unit type:</p>
<pre><code class="language-back">unit seconds;

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">func</span> main() {
    <span class="token keyword">let</span> time = <span class="token number">12</span>&lt;seconds>;
}
</code></pre>
<h2 id="implicit-casts">Implicit Casts</h2>
<p>Sometimes you want to pass number values of a specific type that is smaller than the required type. Backlang allows you to use those values by an implicit cast. For example: you can use a i32 value if a variable has the type i64. As long there are the same kind of type. </p>
<p>You can also write a custom operator overload to make your custom types implicit castable.</p>
